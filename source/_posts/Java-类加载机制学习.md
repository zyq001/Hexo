title: Java 类加载机制学习
date: 2015-03-02 23:43:31
tags: [Java, JVM]  
categories: [Java] 
thumbnail: /images/loader_gif.gif
banner: /images/loader_01.jpg
---

# 虚拟机类加载机制：  
&#8195;&#8195;**虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。  
&#8195;&#8195;Java语言里，类型的**加载**和**连接**过程是在**程序运行**期间完成的。  

类的**生命周期：**  
　　**加载** loading  
　　**验证** verification  
　　**准备** preparation  
　　**解析** resolution  
　　**初始化** initialization  
　　**使用** using  
　　**卸载** unloading  

&#8195;&#8195;**加载**、**验证**、**准备**、**初始化**、**卸载**5个阶段顺序是确定的，按这个顺序“开始”的。  
&#8194;&#8194;&#8194;&#8194;解析可能发生在初始化之后，为了支持动态绑定通常互相交叉地混合进行一个阶段执行的过程中调用、激活另一阶段。

## 主动引用&被动引用：  
---
<!-- more -->
有且只有以下四种情况必须立即对类进行”**初始化**”(称为对一个类进行**主动引用**)：  


- 遇到new、getstatic、putstatic、invokestatic这四条字节码指令时(使用new实例化对象的时候、读取或设置一个类的静态字段、调用一个类的静态方法)。  


- 使用java.lang.reflet包的方法对类进行反射调用的时候。  


- 当初始化一个类的时候，如果发现其父类没有进行过初始化，则需要先触发其父类的初始化。  


- 当虚拟机启动时，虚拟机会初始化主类(包含main方法的那个类)。  

**被动引用：**  


- 通过**子类引用父类**的**静态字段**，不会导致子类初始化(对于静态字段，只有直接定义这个字段的类才会被初始化)。  


- **通过数组定义类应用类：**ClassA [] array=new ClassA[10]。触发了一个名为[LClassA的类的初始化，它是一个由虚拟机自动生成的、直接继承于Object的类，创建动作由字节码指令newarray触发。
常量会在编译阶段存入调用类的常量池。  


- 编译器会**为接口生成 ()构造器**，用于初始化接口中定义的成员变量。一个接口在初始化时，并**不**要求其**父类接口**全部完成了初始化，只有在真正使用到父接口的时候才会初始化。  

## 加载
---


- 通过一个类的全限定名来获取此类的二进制字节流。  


- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。  


- 在内存中生成一个代表这个类的Class对象，作为方法区这些数据的访问入口。  
{**反射:**就是取得这个class对象(通过"包名+类名".class)，进而获取所有变量和方法，或直接newInstance调用默认构造器new一个对象}  

- **非数组类的加载** 可以自定义加载器（重载一个类加载器的loadClass()方法）

- **数组类：** **类本身不通过类加载器创建**，有JVM直接创建；数组类的元素类型（去掉维数的类型）最终需要类加载器去创建  
- **引用类型：**递归采用类的加载    基本类型（如int[]）：JVM标记为与引导类加载器关联
    数组类可见性与其他组件类型一致，非引用类型数组类可见性默认为public

**完成后：**虚拟机外部的二进制字节流存于**方法区**；内存中实例化一个 java.lang.Class对象（未规范，hotspot存于方法去）

## 验证
---  
工作量占相当大一部分。重要但不必要（对程序运行期没有影响，如果确信运行的全部代码包括第三方包中已反复使用验证，可用-Xverify:none关闭大部分验证）  
**验证：**确保Class文件的字节流中包含的信息**符合当前虚拟机的要求**，并且不会危害虚拟机自身的安全。  
虚拟机规范：如果验证到输入的字节流不符合Class文件的存储格式，就抛出一个java.lang.**VerifyError**异常或其子类异常。  

1. **文件格式验证：**验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。这个阶段的验证时给予字节流进行的，经过了这个阶段的验证之后，字节流才会进入内存的方法区中进行存储所以后面的验证阶段都是给予方法区的存储结构进行的。  
如：**魔数**0xCAFEBASE，版本号，常量池中是否有不被支持的类型

2. **元数据验证：**对类的元数据信息进行语义校验，保证不存在不符合java语言规范的元数据信息。
如：是否有父类，父类是否final，类中字段，方法是否与父类矛盾（覆盖final字段，不合规则重载reload，即参数一致返回值不同）（这些问题编译就不会通过，感觉很多验证有点多余，，不知对否）

3. **字节码验证：**进行数据流和控制流分析，确定语义合法合逻辑,对类的方法体进行校验分析，保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。  
如：保证操作数栈中数据类型与指令代码配合工作（操作栈防止int，使用时却按long加载入本地变量表）； 保证类型转换有效；保证跳转指令不会跳转到方法体外的字节指令上

4. **符号引用验证：**发生在虚拟机将符号引用转化为直接引用的时候(解析阶段)，对常量池中的各种符号引用的信息进行匹配性的校验。  
如：通过权限定名是否能找到对应类；符号引用中类、字段、方法的访问性是否可悲当前类访问  

## 准备
---
准备阶段是正式为**类变量分配内存**并设置**类变量初始值**(各数据类型的零值)的阶段，这些内存将在**方法区**中进行分配。但是如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量值就会初始化为ConstantValue属性指定的值。  
`public static final int value=122;`（final：编译器已放入调用类的常量池；无final，则value为0，初始化时才赋值）  

## 解析
---
解析阶段是在虚拟机将**常量池**内的**符号引用**替换为**直接引用**的过程。  
**符号引用：**符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并**不一定已经加载到内存**中。  
**直接引用：**直接引用可以是直接指向目标的**指针**、**相对偏移量**或者一个能间接定位到目标的**句柄**。如果有了直接引用，那引用的目标必定**已经在内存**中存在。  


1. **类或接口**(对应于常量池的CONSTANT_Class_info类型)的解析：  
假设当前代码所处的类为D，需要将一个从未解析过的符号引用N解析为一个类或接口C的直接引用：  
如果C不是一个数组类型，虚拟机将会把代表C的全限定名传递给D的类加载器去加载这个类。  
如果C是一个数组类型，并且数组的元素类型为对象(N的描述符类似[Ljava.lang.Integer)，将会加载数组元素类型(java.lang.Integer)，接着由虚拟机生成一个代表此数组维度和元素的数组对象。  
如果以上过程没有发生异常，则C在虚拟机中已经成为了一个有效的类和接口了，之后还要进行的是符号引用验证，确认D是否具有对C的访问权限，如果没有，将抛出java.lang.**IllegalAccessError**异常。

1. **字段**(对应于常量池的CONSTANT_Fieldref_info类型)解析：   
对字段表中的class_index项中索引的CONSTANT_Class_info符号引用进行解析。用C表示这个字段所属的类或接口。  
如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用。否则，如果C实现了接口，则会按照继承关系从下往上递归搜索各个接口和他的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用。否则，如果C不是java.lang.Object类型的话，将会按照继承关系从下往上递归的搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用。否则，查找失败，抛出java.lang.NoSuchFieldError异常。  
虚拟机的编译器实现可能会更严格：如果一个同名字段同时出现在C实现的接口和父类中，或者同时在自己或父类的多个接口中出现，编译器将可能拒绝编译。  


1. **类方法**(对应于常量池的CONSTANT_Methodref_info类型)解析：  
对方法表中的class_index项中索引的CONSTANT_Class_info符号引用进行解析。用C表示这个方法所属的类或接口。  
类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class_index中索引的C是个接口，则抛出java.lang.IncompatibleClassChangeError。  
在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用。否则，在C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用。否则，在C实现的接口列表及它们的父接口中递归的查找是否有简单名称和描述符都与目标相匹配的方法，如果有说明C是个抽象类，查找结束，抛出java.lang.AbstractMethodError异常。
否则，查找失败，抛出java.lang.NoSuchMethodError异常。  
如果查找返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对这个方法的访问权限，则抛出java.lang.IllegalAccessError异常。  


1. **接口方法**(对应于常量池的CONSTANT_InterfaceMethodref_info类型)：
对方法表中的class_index项中索引的CONSTANT_Class_info符号引用进行解析。用C表示这个方法所属的类或接口。  
如果在接口方法表中发现class_index中索引的C是个类，则抛出java.lang.IncompatibleClassChangeError。否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用。否则，在接口C的父接口中递归查找，知道java.lang.Object类(包括在内)，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用。否则，查找失败，抛出java.lang.NoSuchMethodError。  

## 初始化
---
初始化阶段是**执行类构造器**<clinit> ()方法的过程。  


1. ()方法是由编译器自动收集类中的 所有类变量的赋值动作和静态语句块(static{}块)中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的。   
静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但是不能访问。  


1. 方法与实例构造器 ()不同，不需要显示的调用父类构造器，虚拟机会保证在子类的 ()方法执行之前，父类的 ()已经执行完毕。


1. ()方法对于类或接口来说不是必须的，如果一个类中没有静态语句块也没有对变量的赋值操作，那么编译器可以不为这个类生成 ()方法。


1. 执行接口的 ()不需要先执行父接口的 ()方法，只有当父接口中定义的变量被使用时，父接口才会被初始化。 接口的实现类在初始化时也不会执行接口的 ()方法 。


1. 虚拟机会保证一个类的 ()方法在多线程环境中被正确的加锁和同步，如果多个线程同时去初始化一个类，则只会有一个线程去执行这个类的               ()方法，其他线程需要阻塞等待 。


# 类加载器
---
都有**独立的类名称空间**：比较两个类是否相等 前提是由同一个类加载器加载；否则，即使同一个class文件，相同虚拟机加载，但类加载器不同，这两个类必定不同。  
### 双亲委派模型：（规范推荐，非强制） 
![ClassLoader](/images/JvmLoad/classLoader.jpeg)
**启动类加载器**（Bootstrap ClassLoader）<--**扩展类加载器**（Extension ClassLoader）<--**应用程序**  
先传给父类加载器，父类加载器无法加载，子类加载器才会尝试加载。保证基础类被同一个加载器加载；如java.lang.Object永远会被Bootstrap ClassLoader加载
 
新建一个rt.jar中重名的类，编译成功，但永远无法被加载，即使使用自定义类加载器强行加载也不行，还会抛异常SecurityException  
**被破坏：**OSGi：平级搜索类加载器

### 对象创建：
类加载-开内存-引用入栈本地变量表（及当前调用new对象的方法的本地变量表）
引用reference：①存句柄地址 句柄包含具体对象实例数据和类型数据地址信息；优点：稳定的引用地址，对象被移动只需改变句柄里的地址，缺点：多一次指针定位的开销
②直接指针：存对象地址 快  HotSpot采用
